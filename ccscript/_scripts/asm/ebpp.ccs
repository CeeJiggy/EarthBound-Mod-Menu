/*
 *	EB++ :: CCScript library
 *
 *	version 0.999
 */
	
/* EB++ CONTROL CODES */

// # GENERIC
command asmcall_long(addr)		{ "[1B 07 {mem24(addr)}]" }
command asmcall_short(addr, rb)	{ "[1B 08 {mem24(addr)} {short rb}]" }
command printb(r, z)			{ "[1B 0A {byte r} {byte z}]" }
command printd(r, z)			{ "[1B 0B {byte r} {byte z}]" }
command printh(r, z)			{ "[1B 0C {byte r} {byte z}]" }
command reg_txtjmp(r)			{ "[1B 0D {byte r}]" }
command reg_txtcall(r)			{ "[1B 0E {byte r}]" }
command reg_asmcall(r)			{ "[1B 0F {byte r}]" }

// # LOADING / STORING
command load8(r, addr)			{ "[1B 10 {byte r} {mem24(addr)}]" }
command load16(r, addr)			{ "[1B 11 {byte r} {mem24(addr)}]" }
command load24(r, addr)			{ "[1B 12 {byte r} {mem24(addr)}]" }
command load32(r, addr)			{ "[1B 13 {byte r} {mem24(addr)}]" }
command store8(r, addr)			{ "[1B 14 {byte r} {mem24(addr)}]" }
command store16(r, addr)		{ "[1B 15 {byte r} {mem24(addr)}]" }
command store24(r, addr)		{ "[1B 16 {byte r} {mem24(addr)}]" }
command store32(r, addr)		{ "[1B 17 {byte r} {mem24(addr)}]" }
command load16c(r, constant)	{ "[1B 18 {byte r} {short constant}]" }
command load32c(r, constant)	{ "[1B 19 {byte r} {long constant}]" }
command mov_reg_result(r)		{ "[1B 1A {byte r}]" }
command mov_reg_argument(r)		{ "[1B 1B {byte r}]" }
command mov_reg_counter(r)		{ "[1B 1C {byte r}]" }
command mov_result_reg(r)		{ "[1B 1D {byte r}]" }
command mov_argument_reg(r)		{ "[1B 1E {byte r}]" }
command mov_counter_reg(r)		{ "[1B 1F {byte r}]" }

// # MANIPULATION
command add(x, l, r)			{ "[1B 20 {byte x} {byte l} {byte r}]" }
command sub(x, l, r)			{ "[1B 21 {byte x} {byte l} {byte r}]" }
command mul(x, l, r)			{ "[1B 22 {byte x} {byte l} {byte r}]" }
command div(x, m, l, r)			{ "[1B 23 {byte x} {byte m} {byte l} {byte r}]" }
command bwand(x, l, r)			{ "[1B 24 {byte x} {byte l} {byte r}]" }
command bwor(x, l, r)			{ "[1B 25 {byte x} {byte l} {byte r}]" }
command bwxor(x, l, r)			{ "[1B 26 {byte x} {byte l} {byte r}]" }
command push(r)					{ "[1B 27 {byte r}]" }
command pull(r)					{ "[1B 28 {byte r}]" }
command copy(d, s)				{ "[1B 29 {byte d} {byte s}]" }

// # MANIPULATION (CONSTANT)
command addc(x, l, r)			{ "[1B 30 {byte x} {byte l} {long r}]" }
command subc(x, l, r)			{ "[1B 31 {byte x} {byte l} {long r}]" }
command mulc(x, l, r)			{ "[1B 32 {byte x} {byte l} {long r}]" }
command divc(x, m, l, r)		{ "[1B 33 {byte x} {byte m} {byte l} {long r}]" }
command bwandc(x, l, r)			{ "[1B 34 {byte x} {byte l} {long r}]" }
command bworc(x, l, r)			{ "[1B 35 {byte x} {byte l} {long r}]" }
command bwxorc(x, l, r)			{ "[1B 36 {byte x} {byte l} {long r}]" }
command pushc(r)				{ "[1B 37 {long r}]" }
command pop						{ "[1B 38]" }
command alloc(c)				{ "[1B 39 {short c}]" }
command ina(d, s)				{ "[1B 3A {byte d} {byte s}]" }
command dec(d, s)				{ "[1B 3B {byte d} {byte s}]" }
command shl(d, s)				{ "[1B 3C {byte d} {byte s}]" }
command shr(d, s)				{ "[1B 3D {byte d} {byte s}]" }
command sload(d, sp)			{ "[1B 3E {byte d} {short sp}]" }
command sstore(d, sp)			{ "[1B 3F {byte d} {short sp}]" }

// # COMPARISON
command eq(x, l, r)				{ "[1B 40 {byte x} {byte l} {byte r}]" }
command neq(x, l, r)			{ "[1B 41 {byte x} {byte l} {byte r}]" }
command gte(x, l, r)			{ "[1B 42 {byte x} {byte l} {byte r}]" }
command lte(x, l, r)			{ "[1B 43 {byte x} {byte l} {byte r}]" }
command gt(x, l, r)				{ "[1B 44 {byte x} {byte l} {byte r}]" }
command lt(x, l, r)				{ "[1B 45 {byte x} {byte l} {byte r}]" }

// # COMPARISON (CONSTANT)
command eqc(x, l, r)			{ "[1B 50 {byte x} {byte l} {long r}]" }
command neqc(x, l, r)			{ "[1B 51 {byte x} {byte l} {long r}]" }
command gtec(x, l, r)			{ "[1B 52 {byte x} {byte l} {long r}]" }
command ltec(x, l, r)			{ "[1B 53 {byte x} {byte l} {long r}]" }
command gtc(x, l, r)			{ "[1B 54 {byte x} {byte l} {long r}]" }
command ltc(x, l, r)			{ "[1B 55 {byte x} {byte l} {long r}]" }

// # MISCELLANEOUS
// author's note: [1B 60-63] is listed below, under movement-related stuff.
command window_title(w, p)		{ "[1B 64 {byte p} {byte w}]" }
command memset(p, v, r)			{ "[1B 65 {byte p} {byte v} {byte r}]" }
command memcpy(f, t, r)			{ "[1B 66 {byte f} {byte t} {byte r}]" }

// # LOADING / STORING (INDIRECTION/POINTERS)
command pload8(d, s)			{ "[1B 70 {byte d} {byte s}]" }
command pload16(d, s)			{ "[1B 71 {byte d} {byte s}]" }
command pload24(d, s)			{ "[1B 72 {byte d} {byte s}]" }
command pload32(d, s)			{ "[1B 73 {byte d} {byte s}]" }
command pstore8(s, d)			{ "[1B 74 {byte s} {byte d}]" }
command pstore16(s, d)			{ "[1B 75 {byte s} {byte d}]" }
command pstore24(s, d)			{ "[1B 76 {byte s} {byte d}]" }
command pstore32(s, d)			{ "[1B 77 {byte s} {byte d}]" }

// A shortcut for peeking at the top of the stack.
command peek(r) {
	pull(r)
	push(r)
}

/* MOVEMENT / DEMO STUFF */

// Demo numbers for the demo sequence pointer-table.
define DEMO_SUMMERS		= 0 	// 1st demo sequence
define DEMO_THREED		= 1 	// unused/hidden demo sequence -- Ness & Paula walk around zombie Threed cemetary.
define DEMO_DEEPDARK	= 2 	// 2nd
define DEMO_BUS			= 3 	// 3rd
define DEMO_PYRAMID		= 4 	// 4th
define DEMO_TWOSON		= 5 	// 5th
define DEMO_SCARABA		= 6 	// 6th
define DEMO_FOURSIDE	= 7 	// 7th
define DEMO_SUMMERS_X	= 8 	// unused/hidden demo sequence -- Ness & co. walk around upper summers.
define DEMO_GIANT		= 9 	// 8th

// Movement pattern numbers for each demo sequence.
define MOVE_SUMMERS				= 0x0217
define MOVE_THREED				= 0x0218
define MOVE_DEEPDARK			= 0x0219
define MOVE_DEEPDARK_PETUNIA1	= 0x002C	// I'm assuming this is a "stay still" movement code.
define MOVE_DEEPDARK_PETUNIA2	= 0x021A	// Demonic Petunia has its own movement code for this particular demo sequence, when it moves east a little towards the party.
define MOVE_BUS					= 0x021B
define MOVE_BUS_SCOOP			= 0x021C	// The dirt scooper in this demo sequence has its own movement code, heading east.
define MOVE_PYRAMID				= 0x021D
define MOVE_TWOSON				= 0x021E
define MOVE_SCARABA				= 0x021F
define MOVE_FOURSIDE			= 0x0220
define MOVE_SUMMERS_X			= 0x0221
define MOVE_GIANT				= 0x0222


/*
 * ROM manipulation helpers 
 */

// Converts a number to a little-endian formatted 24-bit value.
command mem24(n) { 
	"[{short n}{byte [2] n}]"
}

// Links an item's help text pointer to a label.
command item_link(itemnum, target) {
	ROMTBL[0xD55023, 0x27, itemnum] = target
}

// Links a movement sequence to a label.  (Obsoleted by new arbitrary movement-pattern calling control codes.)
command mov_link(seqnum, target) {
	ROMTBL[0xC400D4, 0x03, seqnum] = mem24(target)
}

// Links a demo sequence to a label.
command demo_link(seqnum, target) {
	ROMTBL[0xC3FD8D, 0x04, seqnum] = target
}

// Sets which demo is played in which slot.
// There are a maximum of 10 demoes: 0-9, and there are a maximum of 8 slots: 0-7.
command demo_slot(seqnum, slot) {
	ROMTBL[0xC4DC48, 0x0C, slot] = byte seqnum
}

// Changes the demo's music track.
command demo_music(tracknum) {
	ROM[0xC4DC41] = byte tracknum
}
	
// Change the style of the spotlight:
// 0 - normal
// 1 - wide
// 2 - closes (difficult to explain without seeing it)
command spotlight_style(style) {
	ROM[0xC4DA12] = byte style
}


/*
 * New movement-related control codes
 */

// Creates a TPT entry with an arbitrary movement pattern, pointed to by ptr.
command create_tpt_movaddr(entry, ptr, effect) {
	"[1B 60 {short entry} {mem24(ptr)} {byte effect}]"
}

// Creates a sprite with an arbitrary movement pattern, pointed to by ptr.
command create_sprite_movaddr(entry, ptr, effect) {
	"[1B 61 {short entry} {mem24(ptr)} {byte effect}]"
}

// Gives an on-screen TPT entry an arbitrary movement pattern, pointed to by ptr.
command give_tpt_movaddr(entry, ptr) {
	"[1B 62 {short entry} {mem24(ptr)}]"
}

// Gives an on-screen sprite entry an arbitrary movement pattern, pointed to by ptr.
command give_sprite_movaddr(entry, ptr) {
	"[1B 63 {short entry} {mem24(ptr)}]"
}


/*
 * Movement codes -- these are entirely different from control codes.
 */

command mov_end "[00]"
command mov_loop_start(i) "[01 {byte i}]"
command mov_loop_end "[02]"
command mov_jmlmov(target) "[03 {mem24(target)}]"
command mov_jslmov(target) "[04 {mem24(target)}]"
command mov_rtl "[05]"
command mov_pause(n) "[06 {byte n}]"

// The difference between mov_halt and mov_end seems to be that mov_end either erases
// or makes invisible the active entry.  mov_halt just finishes the movement pattern in question
// and leaves the entry alone after that.
command mov_halt "[09]"

command mov_tablewrite(i, w) "[0E {byte i} {short w}]"

command mov_ramwrite(w, b) "[12 {short w} {byte b}]"

command mov_jmpmov(target) "[19 {short target}]"
command mov_jsrmov(target) "[1A {short target}]"
command mov_rts "[1B]"

command mov_loadtmp(c) "[1D {short c}]"

// Sets active entry's X and Y co-ordinates, in pixels.  Multiply map tile sector by 32 to get co-ordinates.
command mov_setx(n) "[28 {short n}]"
command mov_sety(n) "[29 {short n}]"
command mov_setxy(x,y) "[28 {short x} 29 {short y}]"

// Moves active entry by N.  This number is signed, so FFFF is negative 1, FFFE is negative 2, etc.
command mov_movx(n) "[2B {short n}]"
command mov_movy(n) "[2C {short n}]"

// Long calls assembly.
command mov_jslasm(target) "[42 {mem24(target)}]"

// Long-calls a short-returning movement pattern subroutine.  Fill fivebyte in with a location of a 0x05 byte in the bank you're calling to.
// This is a non-standard movement control code only found in EB++.
// (Make sure your fivebyte address is a non-header address.  Subtract 0x200 if you have a header.)
command mov_jslmov_short(target, fivebyte) "[4D {short target}{byte [2] target} {short fivebyte}]"


/*
 * Movement subroutines
 */

// Calls an arbitrary block of text from within a movement pattern.
command movs_calltext(target) {
	mov_jslasm(0xC0A88D)
	"[{byte [2] target} 00 {short target}]"
}

// Cease walking animation.
command movs_stop {
	mov_tablewrite(4,1)	//"[0E 04 01 00]"
}

// Start walking animation.
command movs_go {
	mov_tablewrite(4,0)	//"[0E 04 00 00]"
}

// Gradually moves the active entry to the destination (X,Y), in pixel co-ordinates.
command movs_walker(x, y) {
	mov_tablewrite(0x06, x)
	mov_tablewrite(0x07, y)
	mov_jslmov_short(0xC3AB59, 0x01F6)
}

// Like movs_walker, but the direction the sprite faces seems to be... backwards.  Think moon-walking.  Or driving in reverse.
command movs_slider(x, y) {
	mov_tablewrite(0x06, x)
	mov_tablewrite(0x07, y)
	mov_jslmov_short(0xC3AB67, 0x01F6)
}

// Changes the active sprite using the current movement code's direction.
// At the moment, it only seems to work for the party or if the sprite is animated.
command movs_dir(dir) {
	mov_jslasm(0xC0A651) "[{byte dir}]"
}

// Another direction-setting subroutine.  Only works for currently animating sprites.
command movs_dirB(dir) {
	mov_loadtmp(dir)
	mov_jslasm(0xC0A65F)
}

// Continually walk the active sprite in the specified direction until interrupted.
command movs_dirwalker(dir) {
	mov_loadtmp(dir)
	mov_jslmov_short(0xC3AA1E, 0x01F6)	// "[1A 1E AA]" directional walker subroutine, same one used in the flyovers.
}

// This seems to make the sprite warp to the party, or perhaps the camera.
command movs_partyjump {
	mov_jslmov_short(0xC34E73, 0x01F6)
}

// Initialization routines.
command movs_init(speed, style) {
	mov_jslmov_short(0xC3AA38, 0x01F6)			// Sets the sprite up to be animated. (walking in place)
	mov_jslasm(0xC0A685) "[{short speed}]"
	mov_tablewrite(5, byte style)
}

command movs_init_noanim(speed, style) {
	mov_jslmov_short(0xC3DBE0, 0x01F6)			// Sets the sprite up to not be animated.
	mov_jslasm(0xC0A685) "[{short speed}]"
	mov_tablewrite(5, byte style)
}


/*
 * Demo-specific movements
 */

// Shows "produced by Shigesato Itoi."
command demo_itoi {
	mov_jslasm(0xC4DD28)			// Shows "produced by Shigesato Itoi."
	mov_ramwrite(0x001A, 0x17)		// Keeps the background from disappearing after loading "Shigesato Itoi."
}

// Shows "presented by Nintendo."
command demo_nintendo {
	mov_jslasm(0xC4DDD0)
	mov_ramwrite(0x001A, 0x17)		// Keeps the background from disappearing.
}

// Marks the end of a movement pattern.  Not necessarily the end of the entire demo sequence.
command demo_stop {
	mov_jslasm(0xC0A8A0)			// "[42 A0 A8 C0]"
	"[C5 00 DF E5]"					// arguments
}

// End movement codes for a demo sequence movement.
command demo_end {
	demo_stop
	mov_jslasm(0xC46E46)			// "[42 46 6E C4]"
	mov_halt						// "[09]"
}
